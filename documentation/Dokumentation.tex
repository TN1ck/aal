
\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{listings}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{graphicx}

\newcommand{\code}[1]{{\fontfamily{cmvtt}\selectfont #1}}
\newcommand{\HRule}{\rule{\linewidth}{0.1pt}} % Defines a new command for the horizontal lines, change thickness here

\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\begin{document}
% \title{Dokumentation Projekt AAL}
% \author{Tom Nick\\Jonathan Seilkopf\\Niklas Gebauer\\Maximilian Bachl\\Tom Lehmann}
% %\subtitle{Applikationsgruppe}
% \maketitle
% \newpage


\begin{titlepage}


\center % Center everything on the page
 
%	HEADING SECTIONS

\textsc{\LARGE Technische Universität Berlin}\\[2.5cm] % Name of your university/college
\textsc{\Large Projekt AAL}\\[0.5cm] % Major heading such as course name
\textsc{\large Applikationsgruppe}\\[0.5cm] % Minor heading such as course title


%	TITLE SECTION

\HRule \\[0.6cm]
{ \textsc{\Huge Dokumentation}}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%	AUTHOR SECTION

% \begin{minipage}{0.4\textwidth}
% \begin{flushleft} \large
% \emph{Author:}\\
% John \textsc{Smith} % Your name
% \end{flushleft}
% \end{minipage}
% ~
% \begin{minipage}{0.4\textwidth}
% \begin{flushright} 
% \large
% \emph{Supervisor:} \\
% Dr. James \textsc{Smith} % Supervisor's Name
% \end{flushright}
% \end{minipage}\\[4cm]

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\
Tom Nick\\
Jonathan Seilkopf\\
Niklas Gebauer\\
Maximilian Bachl\\
Tom Lehmann\\
[3cm] % Your name

%	DATE SECTION

{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise

\includegraphics{TU_Logo.pdf}\\[1cm] % Include a department/university logo - this will require the graphicx package

\vfill % Fill the rest of the page with whitespace
\end{titlepage}



\tableofcontents


\chapter{Entwicklerhandbuch}
	\section{Installation}
	Für die vollständige Lauffähigkeit unserer finalen Abgabe, müssen folgende Programme installiert sein:
	\begin{itemize}
		\item \href{http://github.com}{Git (nötig, um den Programmcode von Github herunterzuladen)}
		\item \href{http://www.playframework.com}{Play}
		\item \href{http://nodejs.org}{node.js}
		\item \href{http://www.oracle.com/technetwork/java/javase/downloads/java-se-jre-7-download-432155.html}{Java 1.7} 
		\item \href{http://www.google.de/intl/de/chrome/browser/}{Google Chrome}
	\end{itemize}
	Zum Starten des Projekts muss zunächst das Play-Backend gestartet werden. Das kann getan werden, indem aus dem Projektverzeichnis heraus Play mit
	\code{play run} via Konsole gestartet wird. Nachdem der Server fertig geladen hat, muss die Seite einmalig über die Adresse \url{http://localhost:9000} gestartet werden.
	Bei diesem Aufruf werden die Jiac-Agenten initialisiert und gestartet. Wird die Seite mehrmals über diese URL geladen, werden die Jiac-Agenten mehrfach gestartet. Das kann zu undefiniertem Verhalten führen und sollte deshalb vermieden werden. Nach dem ersten Aufruf, wechselt der Status zu \url{http://localhost:9000/index.html\#/nouser}. Ab sofort reagiert die Wall auf einkommende Nachrichten und ändert ihren Status selbstständig.

	\section{Projektstruktur}
		\subsection{Allgemeiner Aufbau}
			Aus diversen Gründen haben wir uns dazu entschieden das Frontend mit dem, von Google entwickelten, Javascript-Framework AngularJS\footnote{\href{http://angularjs.org/}{http://angularjs.org/}} zu entwickeln. Die komplette Frontendimplementierung befindet sich im Unterordner \code{public/angular/app}. Die Widgets haben wir als Angular-Directives implementiert und diese befinden sich im \code{scripts/directives}-Ordner. Allgemeine Funktionen, welche die gesamte Applikation beziehungsweise den gerade relevanten Teil der Applikation betreffen, werden in den Controllern realisiert. Für häufig genutzte und ausgliederbare Funktionalität, benutzen wir die Services. Ein weiterer zentraler Bestandteil unserer Applikation ist der AngularUI Router\footnote{\href{http://github.com/angular-ui/ui-router}{http://github.com/angular-ui/ui-router}} welcher für die Anzeige und den Wechsel der einzelnen Zustände zuständig ist. Sämtliche visuell relevanten Codeteile befinden sich in dem Unterordner \code{views}.\\\\
			Unser Backend-Code ist im \code{app}-Verzeichnis abgelegt. Die Aufgabe des Backends  besteht im wesentlichen darin, sich um die Kommunikation mit anderen Gruppen des Projekts via Jiac zu kümmern und das Frontend mit Daten zu versorgen. Weiterhin stellt es der Wallapplikation sowie den Mobilgeräten, welche zur Bedienung ebenjener verwendet werden, die Websockets als Kommunikationskanal zur Verfügung.

		\subsection{Frontend}
			\subsubsection{Controllers}
				\paragraph{AuthCtrl}
					Der Auth-Controller ist aktiv, wenn sich die Applikation in einem für die Nutzererkennung relevanten Zustand befindet. Also wenn sie anzeigt, dass gerade eine Erkennung durchgeführt wird oder ein Nutzer als bekannt oder unbekannt identifiziert wurde. Er stellt unter Anderem die Funktionen \code{startTraining} sowie \code{recognizeAgain} bereit, welche über Buttonklicks aufgerufen werden können und die Einleitung eines Trainings- oder Erkennungsprozesses durch das Backend initiieren. Weiterhin stellt er die, für die Anzeige des QR-Codes, relevanten Daten zur Verfügung.
				\paragraph{MainCtrl}
					Der Main-Controller ist in unserer Applikation praktisch der root-Controller. Er wird beim Start als erstes geladen, empfängt \code{ADD\_USER} und \code{REMOVE\_USER} Nachrichten unseres Backends und kümmert sich um die korrekte Zustansänderung der Applikation.
				\paragraph{MobileCtrl}
					Der Mobile-Controller ist auf allen, sich auf der Mobilseite \url{http://localhost:9000/index.html\#/mobile} befindenden, Geräten aktiv. Er wartet auf Nachrichten von der Wall, mit der er gepaired ist und initiiert Zustandsänderungen auf der Angularinstanz, welche auf dem Mobilgerät aktiv ist. Weiterhin sendet er, sofern das \code{modal}-Objekt verändert wurde, das neue Objekt an die Wall, sodass sich die Nutzereingaben auf dem Smartphone direkt im, auf der Wall eingeblendeten, Modal-Fenster verfolgen lassen. Initial befindet das Mobilgerät im Zustand \code{wrapper.mobile.navigation}. Das bedeutet zum einen, dass sowohl der Main- als auch der Mobil-Controller aktiv sind und zum anderen, dass in der Subview der \code{views/mobile.html} die \code{views/widgets/mobile/mobile.navigation.html} geladen wird. Diese bietet direkten Zugriff auf die Core-Features der Applikation vom Mobilgerät aus. Das heißt, man kann ohne auf der Wall navigieren zu müssen, Funktionen wie "`Facebook-Login"' oder "`Add Calendar Entry"' ausführen.
				\paragraph{ModalCtrls}
					Die Modal-Controller sind jeweils aktiv, sobald auf der Wall das entsprechende Eingabemodal für die angeforderte Funktionalität angezeigt wird. Sie kommunizieren mit dem Mobilgerät über Websockets und initiieren dadurch gewünschte Zustandsänderungen im MobileCtrl auf dem Mobilgerät. Die gesamte Funktionalität des ModalSocialCtrl, ist in der finalen Abgabe jedoch nicht erreichbar, da das Posten von anderen Gruppen nicht unterstützt wurde.
				\paragraph{SettingsCtrl}
					Der Settings-Controller ist aktiv, sobald in das Settings-Menü navigiert wurde. Das ist lediglich mit einem Mausklick auf den kleinen Button oben rechts möglich. Für den normalen Betrieb muss das Settings-Menü nicht aufgerufen werden. Es bietet sich aber für Testzwecke an, hier bestimmte Aufgaben manuell auslösen zu können (wie z.B. Facebook-Logout). Da das Settings-Menü für den User nicht sichtbar ist, finden sich hier auch noch Buttons, welche nicht mehr gebraucht werden, oder nicht mehr funktionieren.
				\paragraph{TestCtrl}
					Der Test-Controller simuliert lediglich das Eintreffen von \code{ADD\_USER} bzw. \code{REMOVE\_USER} Nachrichten mit verschiedenen User- und Nite-IDs um die, sich im Main-Controller befindende, Logik zu testen oder einzelne Widgets mit Testdaten zu versorgen. Dazu werden die Nachrichten auf den entsprechenden Kanälen der Websockets versendet.\\
				\HRule
			\subsubsection{Directives}
				\paragraph{Calendar}
					Das Calendar-Widget holt sich seine Daten über einen eigenen "`CALENDAR"'-Channel des Websockets. Außerdem ist hier die Funktionalität zum Hinzufügen eines eigenen Kalendereintrags vorhanden, welche dann das entsprechende Modal öffnet, dessen Controller sich dann um die Kommunikation mit dem Mobilgerät kümmert. Weiterhin benutzen wir Bootstrap\footnote{\href{http://getbootstrap.com/}{http://getbootstrap.com/}} Popovers, um weitere Detailinformationen zu einem Kalendareintrag anzuzeigen. Dazu dient die Funktion \code{showCalendarEntry} welche das Popover öffnet und mit diesem die entsprechenden Daten übergibt. Die zusätzlichen Directives \code{widgetCalendarSmall}, \code{widgetCalendarMiddle} bzw. \code{widgetCalendarBig} dienen lediglich dazu eine modularere, übersichtlichere und elegantere Notation in den HTML-Files zu ermöglichen.
				\paragraph{Debug}
					Das Debug-Widget sollte in der finalen Version selbstverständlich nicht mehr angezeigt werden, da es, wie der Name schon andeutet, lediglich zu Debugzwecken verwendet wird. Es zeigt die Anzahl aller bekannten sowie unbekannten Nutzer und die drei zuletzt erkannten Gesten an. Weiterhin zeigt es das für die Gesichtserkennung verwendete Bild, sowie User- und NiteID des jeweiligen Nutzers an. 
				\paragraph{Fair}
					Das Messe-Widget, zeigt lediglich hart codierte Daten an. Diese werden im in der \code{views/fair.html} übergeben. Logik zum holen von Daten ist noch nicht implementiert, da andere Gruppen dieses Szenario nicht unterstützen, ließe sich aber mit geringem Aufwand aus einem der anderen Widgets ableiten. 
				\paragraph{Mail} 
					Das Mail-Widget holt sich seine Daten über einen eigenen "`MAIL"'-Channel des Websockets. Der Rest der Funktionalität ist beinahe Äquivalent zum Calendar-Widget.
				\paragraph{Widget}
					Das Widget-Directive ist eine Art Wrapper dem wir die Daten für das eigentliche Widget sowie einen Widget-Type übergeben. Es fügt dann einen HTML-Tag mit typspezifischen CSS-Klassen um den eigentlichen Widget-Tag herum ein. Das hat den Vorteil, dass man beim Hinzufügen von Widgets in der \code{views/main.html} weniger beachten muss.
				\paragraph{Maps}
					Das Maps-Widget zeigt Google-Maps an. Man kann seinen Standort bestimmen und dann Dinge sehen, die es in der Nähe zu erkunden gibt. Das Google-Maps ist in der finalen Version allerdings nicht mehr enthalten, da wir lieber auf andere Widgets zurückgegriffen haben. Es lässt sich allerdings bei Bedarf wieder aktivieren.
				\paragraph{News}
					Das News-Widget wartet lediglich auf Daten in dem "`NEWS"'-Channel des Websockets und bietet eine Funktion um einen Newsbeitrag in einem Modal detailiert anzuzeigen.
				\paragraph{Personal}
					Das Personal-Widget zeigt persönliche Informationen des Users an. Diese holt es sich über den "`FACEBOOK"'-Channel des Websockets. Weiterhin kann man sich den QR-Code, welcher auf die Mobilseite verlinkt mit einem Modal in groß anzeigen lassen.
				\paragraph{Social-Comparison (Social-Graph)}
					Das Social-Widget zeigt dem User aktuelle Facebook-Posts aus seinem Facebookstream an. Die Daten bekommt es aus dem "`SOCIAL"'-Channel. Weiterhin stellt es die Möglichkeit zur Verfügung detailierte Informationen zu einem Post, wie Anzahl an Likes und Kommentaren, sowie die ersten Kommentare in einem Popover anzuzeigen. Auch das "`Liken"' eines Facebook-Posts ist möglich, die Daten werden über das Facebook API übertragen.\\
Es gibt auch ein Feature, das ermöglicht, von der Wall aus auf seine Facebook-Pinnwand zu posten.
				\paragraph{Social}
					Das Social-Widget zeigt dem User aktuelle Facebook-Posts aus seinem Facebookstream an. Die Daten bekommt es aus dem "`SOCIAL"'-Channel. Weiterhin stellt es die Möglichkeit zur Verfügung detailierte Informationen zu einem Post, wie Anzahl an Likes und Kommentaren, sowie die ersten Kommentare in einem Popover anzuzeigen. Auch das Liken eines Facebookposts ist möglich.
				\paragraph{To Do}
					Das To-Do-Widget zeigt die ToDos an, welche auf dem "`TODO"'-Channel ankommen. \code{showTodo} kümmert sich hier um die Anzeige detailierter Informationen zu einem ToDo.\\
				\HRule
			\subsubsection{Services}
				\paragraph{CSS-Service}
					Hier wird ein Array von CSS-Klassen erstellt, was für jedes Widget eine eigene CSS-Klasse erstellt, die die Farbendarstellung im Widget beschreibt.
				\paragraph{Radial-Service}
					Der Radial-Service ist ein zentraler Bestandteil unserer Applikation. Er stellt das Menü zur Verfügung. Das Menü ist insofern parametrisiert, als dass es nur die tatsächlich vorhandenen Widgets einbezieht und in den Submenüs auch immer nur so viele Auswahlmöglichkeiten anzeigt, wie Daten verfügbar sind. In der anfangs notierten \code{KEYMAPPING}-Variable werden die Tasten deklariert, die der Service für bestimmte Aktionen erwartet. Die Tastendrücke werden im Backend ausgelöst. Das hat den großen Vorteil, dass wir im Frontend direkt auf keypress-Events reagieren können und einige von uns benutzte Elemente, wie beispielsweise Modals, bereits das von uns gewünschte Verhalten (z.B. das Schließen bei Escape-Tastendruck) mitbringen.\\
					Das Verhalten und die Funktionsweise des Menüs lassen sich recht einfach erschließen, indem man den switch-case-Block am Ende des Codes nachvollzieht.
				\paragraph{Social-Comparison-Service}
					Der Social-Comparison-Service ist das Backend für den Social Graph. Hier wird auf das Facebook-API zugegriffen. Durch das modulare Design hat man die Möglichkeit, noch weiter Daten von Facebook herunterzuladen und im Social-Graph zu visualisieren. Das Hinzufügen einer neuen Kategorie benötigt sonst keinen weiteren Aufwand, denn der graphische Teil passt sich dynamisch an die neuen Daten an, die im Source-Code spezifiziert wurden. 
\\
Das konkrete Vorgehen ist folgendes: Zuerst wird der Access-Token für Facebook über \texttt{setToken} für den Service gesetzt. Dann werden die Namen der beteiligten Personen an die Funktion \texttt{compareTwoPersons} übergeben. Anschließend werden alle relevanten Daten von Facebook geholt. Diese Daten werden anschließend gruppiert, auf Gemeinsamkeiten überprüft und zuletzt werden doppelte Datensätze noch gefiltert und Verworfen.
\\
\textsc{JSON}-Objekt wird als Antwort an das Frontend übergeben, weches die Daten dann visualisiert.
				\paragraph{Transmit-Text-Service}
					Der Transmit-Text-Service stellt verschiedene Methoden zur Daten- bzw. Textübertragung via Websocket zur Verfügung. Dabei verwenden die Funktionen welche "`Text"' im Funktionsnamen enthalten stets auf irgendeine Weise die MobileID für den Übertragungschannel, sodass hier nur gepairte Geräte welche die gleiche MobileID verwenden Nachrichten bekommen. Funktionen mit "`Data"' im Funktionsnamen werden benutzt um Daten an Widgets zu senden bzw. diese zu empfangen.
				\paragraph{Websocket-Service}
					Der Websocket-Service wird lediglich vom Transmit-Text-Service benutzt und stellt diesem Funktionen zum Hinzufügen bzw. entfernen von sogenannten Listenern, sowie zum Senden von Nachrichten zur Verfügung.
				\paragraph{Widget-Data-Service}
					Der Widget-Data-Service kümmert sich zum einen um den FB-Login-Status und das Holen und Übertragen der Facebookdaten an das Social-Widget und zum anderen, stellt er die Liste, der über das Menü ansteuerbaren, Widgets inklusive deren Sockets etc. sowie deren Farben zur Verfügung.\\
					\HRule
			\subsubsection{Styles}
				\paragraph{responsive}
					In der responsive.css wird für verschiedene Anzeigeweiten die body-Schriftgröße festgesetzt, sodass die \code{em}-Einheit, welche sich nach der body-Schriftgröße richtet ebenfalls angepasst wird. Außerdem werden für alle von uns verwendeten Bootstrap-Komponenten, die \code{px}-Werte mit passenden \code{em}-Werten überschrieben.\\
					\HRule
			\subsubsection{Views}
				\paragraph{Loading}
				\paragraph{New}
				\paragraph{Train}
				\paragraph{Unknown}
				\paragraph{Userselect}
				\paragraph{Welcome}


	

    \newpage
    \subsection{Backend}
    Der Code für das Backend befindet sich im \code{app}-Verzeichnis.
         \subsubsection{JIAC}
        Zur Kommunikation mit den anderen Projekt-Gruppen benutzen wir das
        Agentenframework JIAC, über das Nachrichten gesendet werden, die für
        das zusammenwirken der einzelnen Teilprojekte nötig sind. Die
        Kommunikation läuft über folgende vier Agenten, welche zu dem
        ApplicationNode gehören: \\
        \paragraph{Gesture Agent}
            Agent zur Kommunikation mit der Gesten und Personenerkennung. \\
        \paragraph{SocialMedia Agent}
            Agent zur Beschaffung von Daten aus
            SocialMedia Plattformen wie z.B. Facebook, aus der Datenbank. \\
        \paragraph{Information Agent}
            Agent zur Beschaffung von News und Verwaltung
            von ToDo's aus der Datenbank. \\
        \paragraph{Communication Agent}
            Agent zur Beschaffung und Verwaltung von
            Mails und Kalender. \\
      
        Die JIAC-Konfigurationsdatei befindet sich im Verzeichnis
        \code{aal/conf/jiac.xml}. \\
                
        
        Die Implementierung der Beans befindet sich im Verzeichnis
        \code{jiac/beans}. Alle Beans erben von der Klasse
        AbstractCommunicatingBean, um die Modellierung der Beans möglichst
        weit zu vereinheitlichen und zu vereinfachen. \\

        \paragraph{Beans}
        Im Folgenden nun eine Auflistung aller Beans mit kurzer Beschreibung,
        wofür sie gebracht werden:
        \begin{itemize}
        \item Gesture Bean: \\
            Sendet Nachrichten zum starten des Trainings
            einer neuen Person und zum erneuten erkennen einer Person, falls
            diese nicht richtig erkannt wurde. \\
            Außerdem Empfängt er Gesten, die über virtuelle Tastendrücke
            Aktionen im Frontend auslösen, und Nachrichten zur
            Benutzererkennung. \\
        \item Todo Bean: \\
            Fordert ToDo's des aktuellen Benutzers an und leitet die
            empfangenen Daten über einen Websocket an das Frontend weiter. \\
            Außerdem bietet er die Möglichkeit Nachrichten zu versenden für das
            Löschen eines existierenden ToDo's und das erstellen eines neuen
            ToDo's. \\
        \item News Bean: \\
            Fordert aktuelle Nachrichten an und leitet die empfangenen Daten an
            das Frontend weiter über einen Websocket. \\
        \item Calendar Bean: \\
            Fordert Kalenderdaten des aktuellen Benutzers an und leitet die
            empfangenen Daten über einen Websocket an das Frontend weiter.
            Außerdem bietet er die Möglichkeit einen veränderten
            Kalendereintrag in der Datenbank zu speichern. \\ 
        \item Mail Bean: \\
            Fordert Mails des aktuellen Benutzers von der Datenbank an und
            leitet die empfangenen Daten über einen Websocket an das Frontend
            weiter. \\
            Zusätzlich bietet er die Möglichkeit des Versendens von Mails. \\
        \item Facebook Bean: \\
            Fordert Facebook-Profildaten des aktuellen Benutzers an. Die
            Nachricht enthält entweder ein gültiges access Token, wenn sich der
            Benutzer neu bei Facebook eingeloggt hat, oder das Feld für das
            Token bleibt leer. In diesem Fall wird das letzte gespeicherte
            access Token von der Datenbank verwendet um die Daten zu
            beschaffen. \\
            Die empfangenen Daten werden über einen Websocket an das Frontend
            weitergeleitet. \\
        \end{itemize}


	\section{Erweiterung}
		\subsection{Widget hinzufügen}
			Zum Hinzufügen eines Widgets müssen folgende Dateien geändert werden:
			\begin{itemize}
				\item{} scripts/services/widget-data.service.js
				\item{} index.html
				\item{} views/main.html 
			\end{itemize}
			Und in den folgenden Ordnern die entsprechenden Dateien für das Widget neu erstellt werden:
			\begin{itemize}
				\item{} scripts/directives/
				\item{} views/widgets/
				\item{} views/modals/ (falls benötigt)
			\end{itemize}
			In der \code{widget-data.service.js} befinden sich am Ende der Datei die beiden Arrays \code{widgets} und \code{colors}. Dort muss jeweils der entsprechende Eintrag für das neue Widget hinzugefügt werden. Dabei ist zu beachten, dass der neue Eintrag an der Position in die Arrays eingetragen werden muss, an der das Widget im Quellcode der \code{main.html} notiert ist, um eine korrekte Funktion des Auswahlmenüs zu gewährleisten.\\\\
			In der \code{index.html} muss die Javascript Datei, welche sich im \code{scripts/directives}-Ordner befinden sollte, für das neue Directive eingetragen werden.\\\\
			Das neue Widget muss, um tatsächlich angezeigt zu werden noch in der \code{main.html} notiert werden. Dabei hängt die Postition von der Stelle an der es im Quellcode steht ab. Dazu müssen entweder andere Widgets entfernt werden oder deren Größe angepasst werden. Das kann über das Zuweisen der entsprechenden \code{row-md}-CSS-Klasse erreicht werden. 
		\subsection{Widget ändern}
			\subsubsection{Position ändern}
				Um die Position des Widgets zu ändern, müssen folgende Dateien angepasst werden:
				\begin{itemize}
					\item{} scripts/services/widget-data.service.js
					\item{} views/main.html 
				\end{itemize}
				In welcher Reihenfolge und Größe die einzelnen Widgets angeordnet sind, wird vollständig in der \code{main.html} beschrieben. Sie werden in drei Spalten angezeigt. Die Höhe eines jeden Widgets (in Grideinheiten) wird über die \code{col-md}-Klasse angegeben. Jede Spalte hat eine Gesamthöhe von acht Grideinheiten. Möchte man jetzt beispielsweise ein Widget der dritten Spalte mit einem Widget der ersten Spalte vertauschen, dann muss man darauf achten, dass die Gesamthöhe der Widgets in der ersten sowie der dritten Spalte auch nach dem Tausch acht beträgt.\\\\
				Anschließend müssen die Arrayeinträge der vertauschten Widgets in den Arrays \code{widgets} und \code{colors} in der \code{widget-data.service.js} so verschoben werden, dass die Einträge in den Arrays wieder die gleiche Reihenfolge aufweisen, wie die in der \code{main.html} notierten Widgets. Ist dies nicht der Fall, kann es zu Problemen mit dem Menü kommen.
			\subsubsection{Logik ändern}
				Um die Logik eines Widgets x zu ändern (z.B. weil sich das Datenformat ändert), müssen folgende Dateien angepasst werden:
				\begin{itemize}
				\item{} scripts/directives/widget.x.js
				\end{itemize}
			\subsubsection{Darstellung ändern} 
				Um die visuelle Darstellung eines Widgets x zu ändern, müssen folgende Dateien angepasst werden:
				\begin{itemize}
					\item{} views/widgets/x/*
				\end{itemize}
				Die jeweiligen \code{small}, \code{middle} und \code{big}-Dateien eines Widgets visualisieren jeweils ein Rechteck mit bestimmten Abmessungen im Bootstrap-Grid. Sollen beispielsweise neue Felder eines Kalendareintrags angezeigt werden, dann muss zunächst entschieden werden, ob sie in allen drei Darstellungsgrößen visualisiert werden sollen oder nur in einer Teilmenge. Die geeignete Darstellung kann dann in den entsprechenden HTML-Dateien notiert werden. Soll die Zusammensetzung oder Reihenfolge der unterschiedlichen Rechtecke des Widgets verändert werden, muss das in der \code{widget.x.html} erledigt werden.
		\subsection{Widget entfernen}
			Um ein Widget nicht mehr anzuzeigen, müssen folgende Dateien geändert werden:
			\begin{itemize}
				\item{} scripts/services/widget-data.service.js
				\item{} views/main.html
			\end{itemize}
			Das zu entfernende Widget muss zum einen aus der \code{main.html} entfernt werden und die anderen, in dieser Spalte dargestellten Widgets, müssen gegebenenfalls in ihrer Höhe, über die Zuweisung einer anderen \code{col-md}-Klasse, angepasst werden.\\\\
			Zum anderen müssen noch die entsprechenden Einträge in den Arrays \code{widgets} und \code{colors} in der \code{widget-data.service.js} entfernt werden.



\chapter{Nutzeranleitung}
\textbf{\textsc{TODO: Alle Schritte noch ausführlicher beschreiben. Ich habe den genauen schrittweisen Ablauf nicht im Kopf}}

\section{Gesten}
Vorab seien die Gesten erklärt, mit denen die Wall bedient werden kann:
\subsection{Geste 1}
foo
\subsection{Geste 2}
bar
\subsection{Geste 3}
spam
\subsection{Geste 4}
eggs

\section{Benutzung}
Im ersten Schritt stellen sich mehrere User -- bis zu fünf ist angesichts der Performance der Kinect-Technologie und des Rechners -- vor die Wall. Der Abstand zur Wall sollte etwa 2m betragen und es empfiehlt sich, möglichst mittig vor der Kinect-Kamera zu stehen.
\\\\
Als nächstes erscheint auf der Wall ein Dialog, in dem die erkannten Gesichter angezeigt werden und die User gebeten werden, grundlegende Daten, wie etwaige Facebook- und Google-Accounts anzugeben. 
\\
Danach erscheint der Social-Graph, um Gemeinsamkeiten zwischen den Usern abzubilden.\\
Haben die User sich über ihre gemeinsamen Interessen ausgetauscht, ist es möglich zur Hauptansicht der Wall zu wechseln.
\\\\
Am Hauptbildschirm angekommen sieht man die Widgets in ihrer kachelförmigen Anordnung. Es sei angemerkt, dass es -- um das Funktionieren einiger Widgets zu gewährleisten -- erforderlich ist, sich bei Facebook und Google einzuloggen. Das Social-Widget, das To-Do-Widget und andere benötigen als Daten-Backend die vorher genannten Service-Anbieter.\\
Durch Gesten lässt sich der Fokus auf ein bestimmtes Widget lenken, in welchem dann weiter Interaktion möglich ist. Das aktuell ausgewählte Widget kann man an der helleren Farbgebung erkennen.


\chapter{Projektbericht}

	In diesem letzten Kapitel der Projektdokumentation möchten wir noch einmal auf besondere Herausforderungen und Leistungen eingehen, sowie eine allgemeine Reflexion des Projekts durchführen.\\\\
	Ziel des Projekts war es, eine "`Living Wall"' zu erstellen, welche den Nutzer in verschiedenen Szenarien unterstützt und Informationen bereitstellt. Unsere Aufgabe war es dabei, für die Visualisierung sowie die Möglichkeit der Texteingabe zu sorgen. Die Realisierung der Aufgabe sollte bis zum Ende des Semesters erfolgen und die Projektfortschritte während zwölf, in wöchentlichem Abstand stattfindenden Terminen, den anderen Projektteilnehmern präsentiert werden. Schlussendlich sollte noch eine Dokumentation, bestehend aus Entwickler- und Userhandbuch, sowie ein Projektbericht erstellt werden.
	
\section{Frontend-Entwicklung}
	Die Aufgabenstellung wirkte sehr reizvoll und wir begannen damit, uns Gedanken über die Möglichkeiten der Darstellung zu machen. Wir entschieden uns dafür, die Darstellung der Informationen in "`Widgets"' zu realisieren. Ein Widget ist eine unabhängige Funktionseinheit, die gemeinsam mit anderen Widgets zur Gesamtanwendung komponiert wird. Ein Beispiel für ein Widget wäre etwa unser Kalender. Neben dem Kalender gibt es z.B.~auch noch das Facebook-Widget. All diese Widgets gemeinsam sind für das Gesamterlebnis der Anwendung verantwortlich. Das hat den Vorteil, dass man einen modularen Aufbau hat und eventuell später erforderliche Funktionalität einfach hinzufügen kann, bzw. in bestimmten Anwendungsfällen nicht benötigte Komponenten ausblenden kann, ohne andere Teile der Anwendung zu beeinträchtigen. Auf dieser Basis arbeiteten wir einige Designentwürfe aus, entschieden uns für geeignete Software und erstellten eine passende Projektstruktur. Bei der Wahl der Software waren insbesondere zwei Faktoren von besonderer Signifikanz. Zum einen sollten wir Jiac zur Kommunikation mit anderen Gruppen einsetzen, sodass unser Backend Java unterstützen musste und zum anderen wollten wir, dass die Vorteile unseres Widgetkonzepts sich auch im Code äußern. Deshalb entschieden wir uns dafür, im Backend Play einzusetzen und im Frontend mit AngularJS zu arbeiten, da die Angular Directives unsere Anforderungen in besonderem Maße erfüllen würden.\\\\
	Bei den Überlegungen zum Design unseres Interfaces war es vonnöten eine Vielzahl von Faktoren zu berücksichtigen, die wir aber zunächst selbst herausfinden mussten und über deren Wichtigkeit wir zum Teil ausführlichst nachgedacht und diskutiert haben, da wir kaum Vorwissen über Interfacedesign mitbrachten.\\\\
	Die nächste große Herausforderung für uns war, wie man unser Interface möglichst intuitiv und sinnvoll bedienen kann. Ein Cursor wurde aus verschiedenen Gründen ausgeschlossen, also überlegten wir uns verschiedene Möglichkeiten die Wand über anders geartete Gesten zu steuern und haben uns schließlich für "`Vier-Wege-Tabbing"' in Kombination mit der Darstellung eines Menüs zur Unterstützung der Navigation und Interaktion entschieden. Die visuelle Darstellung des Menüs war recht komplex, da wir das Menü generisch implementieren wollten, um es somit unabhängig von der Anzahl der dargestellten Widgets zu gestalten.\\\\
	Weil wir ohnehin eine Mobilseite für die Texteingabe erstellen mussten, welche die Möglichkeit bieten sollte, Texteingaben im Interface der Wall mit Live-Feedback via Smartphone zu realisieren, haben wir uns dafür entschieden, den Inhalt der Mobilseite dynamisch zu updaten. Das heißt, dass sich die Anzeige auf dem Mobilgerät selbstständig ändert, wenn auf der Wall eine Aktion ausgeführt wurde, welche das Mobilgerät erforderlich macht. Wird die Aktion über das Smartphone oder über die Wall beendet, kehrt die Mobilseite automatisch in einen Zustand zurück, in dem die Kernfeatures der Wall (z.B. Mail erstellen) direkt mit einem Knopfdruck ausgelöst werden können und sich der Zustand auf dem Mobilgerät dementsprechend anpassen würde. Wir haben also für gekoppelte Geräte und die Wall einen asynchrone Echtzeitkommunikationskanal aufgebaut, um dem User das bestmögliche Feedback, direktes visuelles Livefeedback, zu ermöglichen. Um die Orientierung des Nutzers zu vereinfachen, haben wir bei der Implementierung darauf geachtet, dass sowohl das Fenster auf der Wall, als auch der auf dem Mobilgerät angezeigte Dialog das selbe Template benutzen und sich somit, bis auf einige bildschirmgrößenspezifische Unterschiede, visuell gleichen und die Anpassung und Wartung des Codes vereinfacht wird.
\\\\
Zuletzt sei zum Frontend noch der Social-Graph erwähnt. Wie vorhin schon erläutert ermöglicht er nach der Erkennung die Darstellung von Gemeinsamkeiten, damit User möglicherweise schon ein Gesprächsthema oder gemeinsames Interesse zu Beginn der Wall-Interaktion erkennen. \\
Ursprünglich war für den Social-Graph -- wie der Name schon sagt -- eine Graph-Darstellung angedacht. Diese hat sich aber im Laufe des Entwurfsprozesses als nicht so praktikabel wie ursprünglich gedacht herausgestellt, da die Anzahl an Gemeinsamkeiten der User kleiner war als gedacht und der Graph somit meistens nur eine Hand voll Knoten hatte und wenig imposant aussah. \\
Darum wurde dann eine tabellarische Darstellung gewählt. Ein Vorteil ist, dass sich bei dieser Form die Kategorien an angezeigten Daten problemlos erweitern lässt. Hierzu sind kaum Änderungen im Backend erforderlich.\\ 
Eine weitere Änderung ist, dass ursprünglich bis zu 5 Leute für den Social-Graph geplant waren. Nach Tests stellte sich aber heraus, dass mit zunehmender Anzahl an Personen, die Ladezeiten -- um die Daten von Facebook zu laden und sie anschließend zu analysieren und darzustellen -- unannehmlich groß wurden.

\section{Backend-Entwicklung}
Im Backend entschieden wir uns wie vorhin schon kurz erwähnt für das Play-Framework. Diese Software ermöglichte uns große Performance und stellte uns auch alle benötigten Funktionen ohne Umwege zur Verfügung. Besondere Erwähnung verdienen hier die \glqq Websockets \grqq. \\
Bei dieser Technologie wird es ermöglicht, auch direkt im laufenden Betrieb vom Server Daten für die Website nachzuladen. Das ganze ist sehr ähnlich zum älteren \glqq \textsc{Ajax} \grqq, mit dem Unterschied, dass Websockets auch der Server spontan Daten an den Client senden kann, ohne dass der Client dies vorher explizit gefordert hat.\\
Somit ermöglichten uns Websockets, dass die Inhalte der Widgets -- etwa Nachrichten oder Facebook-Posts -- live vom Server nachgeladen werden können. Auch ohne Aktualisierung der Website ist es somit möglich, dass die Daten auch über mehrere Tage hinweg aktuell bleiben.

\section{Schlussfolgerungen}
Allgemein kann man festhalten, dass die Motivation für das Projekt in unserer Gruppe sehr groß war und wir besonders zu Beginn sehr begeistert waren. Darum starteten wir auch zügig mit der Entwicklung des Frontends, welches schon sehr schnell konkrete Formen annahm.\\
Ein Problem hierbei war, dass die benutzten Technologien -- sowohl auf Frontend- als auch auf Backend-Seite -- den meisten Gruppenmitgliedern zu Beginn nicht geläufig waren. Das ist an sich kein Problem, da unsere Erfahrung mit derartigen Webprojekten natürlich als Studenten beschränkt ist. Wir unterschätzten aber den Aufwand, den die Einarbeitung erfordert. Besonders Angular-JS ist sehr mächtig, komplex und facettenreich, wodurch eine lange Einarbeitungszeit notwendig wurde. Bezüglich der Entwicklungsarbeiten hätten wir den Einarbeitungsaufwand also großzügiger schätzen sollen.
\\\\
Die Kommunikation mit den anderen Gruppen war generell sehr harmonisch und die Arbeitsatmosphäre war produktiv-angespannt, aber stets höflich und hilfsbereit. Ein Problem allerdings war, dass nicht genug kommuniziert wurde.\\
Manchmal schien es, als ob die Gruppen aneinander vorbeiarbeiten würden, da einfach nicht genug Absprachen getroffen wurden. Wir vermuten, dass dies der bis jetzt mangelnden Erfahrung in großen Gruppenarbeiten der Beteiligten zu schulden ist. \\
Wie auch bezüglich der Entwicklungsarbeiten zuvor, stellt man schnell fest, dass die mangelnde Erfahrung in mancherlei Hinsicht ein Problem darstellte, das aber in gewisser Weise natürlich gegeben war, da die meisten von uns Bachelor-Studenten im 4.~bis 6.~Semester sind.

	TODO: Herausforderungen/Leistungen im Backend und ggf. Social-Graph oder andere Dinge im Frontend, die mir noch nicht eingefallen sind


\end{document}
